// DFA（确定性有限自动机，Deterministic Finite Automaton） 是一种用于表示有限状态机（FSM）的模型，它由一组有限的状态、一个输入符号集、一组状态转移规则、一个初始状态以及一组接受（终止）状态组成。DFA 是有限自动机的一种特殊形式，它具有“确定性”特征，意味着每一个状态在给定的输入符号下只有一个可能的转移路径。

// DFA的核心特点：
// 	1.	确定性：在任意时刻和任意输入下，从一个状态出发只能有一个明确的转移。换句话说，从任何状态出发，对于每个输入符号，状态转移是唯一的。
// 	2.	状态集：DFA 有一个有限的状态集合，包括初始状态、接受状态和其他中间状态。
// 	3.	输入符号集：DFA 的输入符号集（字母表）是有限的。每次输入字符都会根据状态转移规则，确定下一个状态。
// 	4.	状态转移：对于每一个当前状态和输入字符，DFA 会根据状态转移函数明确地转移到下一个状态。每一个状态的转移都是唯一的，且无任何歧义。
// 	5.	接受状态：DFA 有一个或多个接受状态（终止状态）。当 DFA 在处理完输入字符串后处于一个接受状态时，表示输入字符串是被接受的。

// DFA的组成：
// 	•	Q：状态集合，包含所有可能的状态。
// 	•	Σ：输入字母表，包含所有可能的输入字符。
// 	•	δ：状态转移函数，定义了每个状态和输入字符的转移规则。对于 DFA，δ(q, a) = q'，表示在状态 q 读取输入字符 a 后转移到状态 q'。
// 	•	q₀：初始状态，DFA 开始处理输入时所处的状态。
// 	•	F：接受状态集合，表示成功接受输入的状态集合。

// DFA的工作原理：
// 	1.	初始化：DFA 从初始状态 q₀ 开始。
// 	2.	处理输入字符：DFA 读取输入字符串中的每个字符，并通过状态转移函数根据当前状态和输入字符来转移到下一个状态。
// 	3.	判断接受：当整个输入字符串处理完毕后，如果 DFA 处于一个接受状态 q ∈ F，则表示输入字符串被接受；否则，表示输入字符串被拒绝。

// 示例：识别字符串 “cats” 的 DFA

// 假设我们构建一个 DFA 来识别字符串 “cats”。以下是该 DFA 的定义：
// 	•	状态集：Q = {q0, q1, q2, q3, q4}，其中 q0 是初始状态，q4 是接受状态。
// 	•	输入字母表：Σ = {'c', 'a', 't', 's'}。
// 	•	初始状态：q0。
// 	•	接受状态：F = {q4}。
// 	•	状态转移函数：
// 	•	δ(q0, 'c') = q1
// 	•	δ(q1, 'a') = q2
// 	•	δ(q2, 't') = q3
// 	•	δ(q3, 's') = q4
// 	•	对于其他输入字符，都会转移到错误状态（如果输入无效）。

// DFA的示意图：

// (q0) --'c'--> (q1) --'a'--> (q2) --'t'--> (q3) --'s'--> (q4)

// 工作过程：
// 	1.	初始状态为 q0，输入字符 'c'，转移到 q1。
// 	2.	当前状态为 q1，输入字符 'a'，转移到 q2。
// 	3.	当前状态为 q2，输入字符 't'，转移到 q3。
// 	4.	当前状态为 q3，输入字符 's'，转移到 q4，结束并接受输入字符串。

// DFA的关键特点：
// 	•	每个状态有一个明确的转移路径。
// 	•	每个状态的转移对于每个字符都是唯一且确定的。

// 与 NFA 的对比：
// 	•	DFA：每个状态和字符的组合只能有一个转移路径，没有模糊性。
// 	•	NFA（非确定性有限自动机）：一个状态可以对应多个转移路径，可能会有空转移或多个可选路径。

// 总结：

// DFA 是一种非常严格的模型，它要求每个状态对每个输入符号有唯一的转移路径。它是确定性的，因此非常容易理解和实现。在实际应用中，DFA 常用于字符串匹配、词法分析等场景。在这种模型中，状态转移和接受条件都非常清晰和明确。

//!                   DFA                   !\\

#include <iostream>
#include <string>

using namespace std;

// 定义状态
enum State {
    q0, // 初始状态
    q1, // 接收字符 'c' 后的状态
    q2, // 接收字符 'a' 后的状态
    q3, // 接收字符 't' 后的状态
    q4, // 接收字符 's' 后的终止状态
    ERROR // 错误状态
};

// 状态转移函数
State transition(State current, char input) {
    switch (current) {
        case q0:
            if (input == 'c') return q1;
            break;
        case q1:
            if (input == 'a') return q2;
            break;
        case q2:
            if (input == 't') return q3;
            break;
        case q3:
            if (input == 's') return q4;
            break;
        default:
            break;
    }
    return ERROR; // 如果输入无效，返回错误状态
}

// 主程序
bool isValidWord(const string& input) {
    State currentState = q0; // 初始化为起始状态

    for (char c : input) {
        currentState = transition(currentState, c);
        if (currentState == ERROR) return false; // 如果进入错误状态，匹配失败
    }

    // 只有到达终止状态 q4 才算匹配成功
    return currentState == q4;
}

int main() {
    string word;

    cout << "输入一个单词进行匹配（目标单词为 'cats'):";
    cin >> word;

    if (isValidWord(word)) {
        cout << "匹配成功！输入的单词是 'cats'" << endl;
    } else {
        cout << "匹配失败！输入的单词不是 'cats'" << endl;
    }

    return 0;
}